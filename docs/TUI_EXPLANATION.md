# TUI Component Explanation: packetlist.go and app.go

This document provides a detailed explanation of the `packetlist.go` and `app.go` files, which are crucial components of the Text User Interface (TUI) for `packetbreather++`. These files are built using the [Charm Bracelet Bubble Tea](https://github.com/charmbracelet/bubbletea) framework, a powerful library for building highly interactive command-line applications.

## `internal/tui/packetlist.go`

The `packetlist.go` file is responsible for rendering and managing the interactive table that displays a summary of captured network packets. It acts as a dedicated view component within the `Bubble Tea` architecture.

### `packListModel` Struct

```go
type packListModel struct {
	table     table.Model
	allpacket []analyzer.PacketSummary
	width     int
	height    int
}
```

- **`table`**: This field holds an instance of `github.com/charmbracelet/bubbles/table.Model`. `Bubbles` is a collection of common `Bubble Tea` components, and `table` provides a ready-to-use, interactive table widget. This is the core element for displaying the packet data.
- **`allpacket`**: A slice of `analyzer.PacketSummary` structs. This stores the raw packet data, which is processed and formatted into rows for the `table.Model`.
- **`width`**: Stores the current width of the terminal window. Used to dynamically adjust the table's width.
- **`height`**: Stores the current height of the terminal window. Used to dynamically adjust the table's height.

### `Init() tea.Cmd`

```go
func (m packListModel) Init() tea.Cmd {
	return nil
}
```
- The `Init()` method is part of the `tea.Model` interface. For `packListModel`, it currently returns `nil`, indicating that no initial commands need to be run when this model starts. In more complex scenarios, this might be used to fetch initial data asynchronously.

### `Update(msg tea.Msg) (tea.Model, tea.Cmd)`

```go
func (m packListModel) Update(msg tea.Msg) (tea.Model, tea.Cmd) {
	var cmd tea.Cmd
	switch msg := msg.(type) {
	case tea.WindowSizeMsg:
		m.width = msg.Width
		m.height = msg.Height
		m.table.SetWidth(m.width)
		m.table.SetHeight(m.height - 2) // Adjust height for border and potential status line
	}
	m.table, cmd = m.table.Update(msg)
	return m, cmd
}
```
- The `Update()` method is the heart of the `Bubble Tea` application, handling all incoming messages (events).
- It uses a `switch` statement to process different types of messages:
    - **`tea.WindowSizeMsg`**: When the terminal window is resized, this message is received. The model updates its `width` and `height` fields and then adjusts the `table.Model`'s width and height accordingly. The height is reduced by 2 to account for the border and potentially a status line, ensuring the table fits within the visible area.
- After handling its own messages, it passes the message to the embedded `m.table.Update(msg)` to allow the `Bubbles` table component to handle its internal state changes (e.g., cursor movement, scrolling).
- It returns the updated `packListModel` and any `tea.Cmd` generated by the table.

### `View() string`

```go
func (m packListModel) View() string {
	return baseStyle.Render(m.table.View())
}
```
- The `View()` method is responsible for rendering the current state of the model to a string that `Bubble Tea` then prints to the terminal.
- It calls `m.table.View()` to get the string representation of the table.
- Crucially, it wraps the table's output with `baseStyle.Render()`. This `lipgloss.Style` applies a `lipgloss.RoundedBorder()` with a `BorderForeground` color of "240" (a light gray), creating the "closed rectangle" effect around the entire packet list.

### `NewPacketListModel(analyzerResult analyzer.AnalyzerResult) packListModel`

```go
func NewPacketListModel(analyzerResult analyzer.AnalyzerResult) packListModel {
	columns := []table.Column{
		{Title: "No.", Width: 5},
		{Title: "Time", Width: 15},
		{Title: "Source", Width: 15},
		{Title: "Destination", Width: 15},
		{Title: "Protocol", Width: 10},
		{Title: "Length", Width: 8},
		{Title: "Info", Width: 50},
	}

	rows := []table.Row{}
	for _, pkt := range analyzerResult.Packets {
		rows = append(rows, table.Row{
			fmt.Sprintf("%d", pkt.Number),
			pkt.TimeStamp,
			pkt.SrcIp,
			pkt.DstIp,
			pkt.Protocol,
			fmt.Sprintf("%d", pkt.Length),
			pkt.Info,
		})
	}

	t := table.New(
		table.WithColumns(columns),
		table.WithRows(rows),
		table.WithFocused(true),
		table.WithHeight(10), // Initial height, will be adjusted by WindowSizeMsg
	)

	s := table.DefaultStyles()
	s.Header = s.Header.
		BorderStyle(lipgloss.RoundedBorder()).
		BorderForeground(lipgloss.Color("240")).
		BorderBottom(true).
		Bold(false)
	s.Selected = lipgloss.NewStyle().
		Bold(true).
		Foreground(lipgloss.Color("#FAFAFA")).Background(lipgloss.Color("#7D56F4"))
	t.SetStyles(s)

	return packListModel{
		table:     t,
		allpacket: analyzerResult.Packets,
	}
}
```
- This is the constructor function for `packListModel`. It takes an `analyzer.AnalyzerResult` as input, which contains the processed packet summaries.
- **Column Definition**: It defines the columns for the table, including titles and initial widths for "No.", "Time", "Source", "Destination", "Protocol", "Length", and "Info".
- **Row Population**: It iterates through `analyzerResult.Packets` and converts each `PacketSummary` into a `table.Row`, formatting the data appropriately (e.g., converting integers to strings).
- **Table Initialization**: A new `table.Model` is created using `table.New()`, providing the defined columns and rows. It's configured to be `WithFocused(true)` for interaction and `WithHeight(10)` as an initial placeholder (which will be dynamically adjusted by `Update()` when a `WindowSizeMsg` is received).
- **Styling**: It retrieves the `DefaultStyles()` for the table and customizes them:
    - `s.Header`: Applies a rounded border, foreground color, and bold styling to the table header.
    - `s.Selected`: Defines the style for the currently selected row, making it bold with specific foreground and background colors to highlight it.
- Finally, it returns a new `packListModel` instance, initialized with the configured `table` and the raw `allpacket` data.

## `internal/tui/app.go`

The `app.go` file serves as the main application model, orchestrating different TUI components and managing the overall application state. It's the entry point for the `Bubble Tea` program.

### `AppModel` Struct

```go
type AppModel struct {
	packetList packListModel
	// You can add other models here for different views
	// e.g., detailView detailViewModel
	// hexView    hexViewModel
}
```
- **`packetList`**: This field embeds the `packListModel`. As the application grows, other view models (e.g., `detailViewModel`, `hexViewModel` for displaying packet details or hex dumps) would be added here to manage different application screens or panels.

### `Init() tea.Cmd`

```go
func (m AppModel) Init() tea.Cmd {
	return m.packetList.Init()
}
```
- The `Init()` method of the main `AppModel` delegates the initialization to its `packetList` sub-model. This allows the `packetListModel` to perform any necessary setup when the application starts.

### `Update(msg tea.Msg) (tea.Model, tea.Cmd)`

```go
func (m AppModel) Update(msg tea.Msg) (tea.Model, tea.Cmd) {
	switch msg := msg.(type) {
	case tea.KeyMsg:
		switch msg.String() {
		case "ctrl+c", "q":
			return m, tea.Quit
		}
	}

	var cmd tea.Cmd
	var updatedPacketList tea.Model
	updatedPacketList, cmd = m.packetList.Update(msg)
	m.packetList = updatedPacketList.(packListModel)
	return m, cmd
}
```
- This `Update()` method handles global application messages.
- **Key Bindings**: It checks for `tea.KeyMsg` to handle user input:
    - If "ctrl+c" or "q" is pressed, the application returns `tea.Quit` to terminate the program gracefully.
- After handling global inputs, it passes the message to `m.packetList.Update(msg)` to allow the packet list view to react to events (e.g., arrow keys for navigation).
- **Type Assertion**: The `m.packetList.Update(msg)` returns a `tea.Model` interface. To assign it back to the `m.packetList` field (which is of concrete type `packListModel`), a type assertion `updatedPacketList.(packListModel)` is necessary.
- It returns the updated `AppModel` and any commands generated by its sub-models.

### `View() string`

```go
func (m AppModel) View() string {
	return m.packetList.View()
}
```
- The `View()` method for `AppModel` simply delegates to `m.packetList.View()`. This means that in its current state, the `AppModel` primarily displays the packet list. As more sub-models are added, this method would be expanded to compose the views of multiple components (e.g., using `lipgloss.JoinVertical` or `lipgloss.JoinHorizontal`).

### `NewAppModel(filePath string) (AppModel, error)`

```go
func NewAppModel(filePath string) (AppModel, error) {
	analyzerResult, err := analyzer.Analyzer(filePath)
	if err != nil {
		log.Fatalf("Error analyzing pcap file: %v", err)
		return AppModel{}, err
	}

	packetListModel := NewPacketListModel(*analyzerResult)

	return AppModel{
		packetList: packetListModel,
	}, nil
}
```
- This is the constructor function for `AppModel`. It takes the `filePath` of the pcap file as input.
- **Packet Analysis**: It first calls `analyzer.Analyzer(filePath)` to process the pcap file and obtain an `analyzer.AnalyzerResult`. Error handling is included to gracefully manage issues during file analysis.
- **Packet List Initialization**: It then uses the `analyzerResult` to create a `NewPacketListModel`.
- Finally, it returns a new `AppModel` instance, initialized with the created `packetListModel`.

### `StartTUI(filePath string) error`

```go
func StartTUI(filePath string) error {
	initialModel, err := NewAppModel(filePath)
	if err != nil {
		return err
	}

	p := tea.NewProgram(initialModel, tea.WithAltScreen())
	if _, err := p.Run(); err != nil {
		log.Fatalf("Error running program: %v", err)
	}
	return nil
}
```
- The `StartTUI` function is the main entry point for launching the `Bubble Tea` TUI application.
- It creates the `initialModel` by calling `NewAppModel(filePath)`, passing the path to the pcap file.
- It then initializes a new `tea.Program` with the `initialModel` and the `tea.WithAltScreen()` option. `WithAltScreen()` uses the alternate screen buffer of the terminal, which ensures that the TUI application doesn't mess up the user's scrollback history.
- Finally, it runs the `Bubble Tea` program using `p.Run()`. Any errors during the program's execution are logged and cause the application to exit.

This structure allows for a clear separation of concerns, with `packetlist.go` handling the specific view logic for the packet table and `app.go` acting as the central coordinator for the entire TUI application.
